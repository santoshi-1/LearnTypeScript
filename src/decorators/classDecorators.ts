/**
 *
 * We have never instantiated the Aircraft class, but typescript automatically invokes decarators.
 * Decarators are invoked when class is defined by TS at run time and not when class is instantiated.
 * Decarators are fired once throughout the lifecycle of the application.
 *
 * Advantages of decarators -
 * 1.Can add properties and methods to the prototype of object that is generated by the class.
 *  This is possible because class decarators provide access to the constructor of the class which are responsible for instatiating the class.
 *
 * @ts-ignore - ignores the ts error
 *
 */

enum Manufacturers {
  boeing = "boeing",
  airbus = "airbus",
}

interface AircraftInterface {
  aircraftModel: string;
  prototype?: any;
  origin?: string;
  manufacturer?: string;
  type?: string;
  airbusMethod?: () => void;
  boeingMethod?: () => void;
}

//DECARATOR FACTORY
function AircraftManufacturer(manufacturer: Manufacturers) {
  //Actual Decarator
  console.log("Decorator Invoked!");
  return (target: Function) => {
    if (manufacturer === Manufacturers.airbus) {
      target.prototype.origin = "United States Of America";
      target.prototype.manufacturer = Manufacturers.airbus;
      target.prototype.type = "Jet";
      target.prototype.airbusMethod = () => {
        console.log("Function performed by Airbus");
      };
    } else {
      target.prototype.origin = "France";
      target.prototype.manufacturer = Manufacturers.boeing;
      target.prototype.type = "Helicopter";
      target.prototype.boeingMethod = () => {
        console.log("Function performed by Boeing");
      };
    }
  };
}

@AircraftManufacturer(Manufacturers.airbus)
class AirplaneClass implements AircraftInterface {
  constructor(
    public _aircraftModel: string,
    private pilot: string,
  ) {
    console.log("Aircraft class instantiated in Constructor function!");
  }

  public pilotName() {
    console.log(this.pilot);
  }

  public get aircraftModel() {
    return this._aircraftModel;
  }
}

const airCraftObj: AircraftInterface = new AirplaneClass("Airbus A380", "John");
console.log(airCraftObj);

/**
 * Initially, this gives an error since manufacturer property is not present directly inside the Aircraft class.
 * To resolve this we can use a hack by implemnting an interface that contains the manufacturer as an optional field and also
 * prototype as an optional field. Because of this, TS checks the nested structure of the prototype to check for the value manufacture.
 */
console.log(airCraftObj.manufacturer);

airCraftObj.airbusMethod
  ? airCraftObj.airbusMethod()
  : console.log("Method doesnot exist");

@AircraftManufacturer(Manufacturers.boeing)
class HelicopterClass implements AircraftInterface {
  constructor(
    public _aircraftModel: string,
    private pilot: string,
  ) {
    console.log("Aircraft class instantiated in Constructor function!");
  }

  public pilotName() {
    console.log(this.pilot);
  }

  public get aircraftModel() {
    return this._aircraftModel;
  }
}

const helicopterObj: AircraftInterface = new HelicopterClass(
  "Boeing B380",
  "Mark",
);
console.log(helicopterObj);

console.log(helicopterObj.manufacturer);

helicopterObj.boeingMethod
  ? helicopterObj.boeingMethod()
  : console.log("Method doesnot exist");
